# CS50_Study

## 1강 - Computing Thinking

* 2진법 : 전기를 통해 연산하는, 즉 전기를 끄고 키는 방식으로 작동하는 컴퓨터에게 적합한 방식 => 수많은 스위치(트랜지스터)의 on/off를 통해
* 비트 : 0, 1 두가지 값만 가질 수 있는 측정 단위
* 비트열 : 여러 비트를 통해 여러 숫자의 조합을 나타내는 것 ex) 바이트(byte) = 8개의 비트로 이루어진 비트열
* 문자의 표현 : 문자를 숫자로 표현할 수 있는 약속 => ASCII, Unicode 등
* 그림, 영상, 음악의 표현 : RGB와 같이 색을 숫자로 표현
* 알고리즘 : 규칙들의 순서적 나열 => 정확성도 중요하지만 효율성도 중요!
___

## 2강 - C Language
* 컴파일러 : 우리가 직접 작성한 "소스 코드" 를 기계가 이해할 수 있는 "머신 코드"로 바꿔주는 프로그램 => C언어에서는 clang 이라는 명령어 사용
* 형식지정자 : 데이터의 종류를 명시 ex) string
* 컴파일 명령어 : make string => make는 일반적인 명령어, string 은 파일이름 명시
* 오버플로우 : 할당된 메모리의 크기를 초과할 경우 발생 ex) Y2K, 보잉 SW 결함
___

## 3강 - Array
* 컴파일 과정 4단계 : (1) 전처리 -> (2) 컴파일 -> (3) 어셈블 -> (4) 링크
* 전처리 : #으로 시작되는 C 소스코드는 전처리기에 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줌
* 컴파일 : C 언어를 저수준 언어인 어셈블 언어로 컴파일
* 어셈블 : 어셈블 언어를 오브젝트 언어로 변환
* 링크 : 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크라는 컴파일의 마지막 단계가 필요
___

## 4강 - Algorithm
* Big O : 알고리즘 실행시간의 상한 (worst case)
* Big Ω : 알고리즘 실행시간의 하한 (best case)
* 선형 탐색 : 원하는 원소가 발견될때 까지 처음부터 차례대로 탐색 => 정확하지만 효율적이지 않는 방법
* 버블 정렬 : 두개의 인접한 자료값을 비교하면서 위치를 교환하는 방식으로 정렬 => 상한 = O(n^2)
* 선택 정렬 : 배열의 가장 작은 값을 찾아 첫번째 위치의 값과 교환 하는 방식으로 정렬 => 상한 = O(n^2)
* 병합 정렬 : 원소가 하나가 될때 까지 계속해서 반으로 나누다가 다시 합쳐가며 정렬하는 방식으로 정렬 => 상한 = O(n log n) 
___

## 5강 - Memory
* 메모리 : C 언어에서 & 연산자 사용 / 메모리상의 주소는 16진수로 표현됨
* 포인터 : 어떠한 값을 저장하는게 아닌 어떠한 값의 주소(Address)를 저장하는 것
* C언어에서 메모리 할당 함수 => malloc()
* 메모리 누수 : malloc 함수를 이용하여 메모리를 할당한 후에는 free라는 함수를 이용하여 메모리를 해제해줘야 함
             그렇지 않은 경우 메모리에 저장한 값은 쓰레기 값으로 남게 되어 메모리 용량의 낭비가 발생하게 되기 때문
* 메모리 -> machine code : 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장
* 메모리 -> globals : 프로그램 안에서 저장된 전역 변수가 저장
* 메모리 -> heap : malloc으로 할당된 메모리의 데이터가 저장
* 메모리 -> stack : 프로그램 내의 함수와 관련된 것들이 저장
___

## 6강 - Data Structures

